import streamlit as st
import google.generativeai as genai
import json
import uuid
from typing import Dict, List, Any
import time

# SECTION 1: Imports and AI Model Configuration
# Your API key should be securely managed, e.g., via Streamlit secrets.
# This placeholder key needs to be replaced with your actual Gemini API key.
# Make sure the key has access to the specified model.
API_KEY = "" 
genai.configure(api_key=API_KEY)

@st.cache_resource
def get_model():
    """Initializes and caches the generative AI model."""
    try:
        return genai.GenerativeModel('gemini-1.5-flash-latest')
    except Exception as e:
        st.error(f"Failed to initialize the AI model. Please check your API key. Error: {e}")
        st.stop()

model = get_model()

# SECTION 2: Game State Management (Now with Long-Term Memory)
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
if 'inventory' not in st.session_state:
    st.session_state.inventory = {}
if 'game_started' not in st.session_state:
    st.session_state.game_started = False
if 'processing_user_input' not in st.session_state:
    st.session_state.processing_user_input = False

# --- New State Variables for the Two-Tiered Memory System ---
if 'turn_count' not in st.session_state:
    st.session_state.turn_count = 0
if 'cumulative_memory' not in st.session_state:
    st.session_state.cumulative_memory = ""

# SECTION 3: The Two-Tiered AI Memory Engine

def update_cumulative_memory():
    """
    THE CHRONICLER (PGE-based Long-Term Memory).
    This function reads the last 'act' of the game and creates a high-level
    summary, which is then added to the cumulative_memory.
    """
    # Define the length of a game "Act" (e.g., 10 user turns = 20 total messages)
    ACT_LENGTH = 20 
    
    with st.spinner("The Chronicler records your deeds... (Updating long-term memory)"):
        last_act_history = st.session_state.chat_history[-ACT_LENGTH:]
        raw_text_of_act = "\n".join([f"{msg['role'].title()}: {msg['text']}" for msg in last_act_history])

        chronicler_prompt = f"""
        You are the Chronicler, a master historian. Your task is to read the following game transcript and summarize the key events, plot developments, major player decisions, and important NPCs introduced into a single, dense paragraph. This summary will serve as the long-term memory for the game's Dungeon Master. Focus only on the most critical information that must be remembered for the story to remain coherent.

        **Transcript of the Last Act:**
        {raw_text_of_act}

        **Your Concise Summary:**
        """
        try:
            summary_response = model.generate_content(chronicler_prompt)
            new_summary_paragraph = summary_response.text.strip()
            
            # Append this new summary to the long-term memory
            st.session_state.cumulative_memory += new_summary_paragraph + "\n\n"
            st.toast("Long-term memory updated!", icon="üìú")
        except Exception as e:
            st.warning(f"The Chronicler had an issue writing the records: {e}")

def generate_response(user_input: str):
    """
    THE BARD (Tactical, Turn-by-Turn Engine).
    Handles all immediate communication with the AI, updates the game state, 
    and now leverages the long-term memory provided by the Chronicler.
    """
    st.session_state.processing_user_input = True
    st.session_state.turn_count += 1
    
    st.session_state.chat_history.append({"role": "user", "text": user_input})
    
    # --- Check if it's time for the Chronicler to update long-term memory ---
    if st.session_state.turn_count % 10 == 0 and st.session_state.turn_count > 0:
        update_cumulative_memory()

    # The Bard's prompt now includes both long-term and short-term memory.
    system_prompt = f"""
    You are an AI Dungeon Master. Your response MUST be a single, valid JSON object.

    ---
    **THE STORY SO FAR (Long-Term Memory):**
    {st.session_state.cumulative_memory if st.session_state.cumulative_memory else "The story is just beginning."}
    ---
    **CURRENT PLAYER INVENTORY (Immediate State):**
    {json.dumps(st.session_state.inventory, indent=2)}
    ---
    **RECENT EVENTS (Short-Term Memory - Last 5 turns):**
    {json.dumps(st.session_state.chat_history[-10:], indent=2)}
    ---
    **PLAYER'S CURRENT ACTION:**
    {user_input}
    ---

    Based on all the above context, generate your response. Your entire output must be a single JSON object with two keys: "narrative_response" (string) and "item_changes" (a list of objects, each with "action", "name", "description").
    """

    try:
        response = model.generate_content(system_prompt)
        ai_response_text = response.text.strip().replace("```json", "").replace("```", "")
        
        try:
            ai_response = json.loads(ai_response_text)
            narrative = ai_response.get("narrative_response", "The Bard seems to have lost its way. Please try again.")
            item_changes = ai_response.get("item_changes", [])

            # Update inventory based on AI's instructions
            for change in item_changes:
                if all(k in change for k in ["action", "name", "description"]):
                    action, item_name, item_desc = change["action"], change["name"], change["description"]
                    if action == "add":
                        st.session_state.inventory[item_name] = {"description": item_desc}
                        st.toast(f"You acquired: {item_name}!", icon="üì¶")
                    elif action == "remove" and item_name in st.session_state.inventory:
                        del st.session_state.inventory[item_name]
                        st.toast(f"You used: {item_name}.", icon="üóëÔ∏è")
            
            st.session_state.chat_history.append({"role": "assistant", "text": narrative})
            
        except json.JSONDecodeError:
            error_message = f"The Bard is having trouble connecting to the aether. The AI response was not valid JSON. Response received:\n\n{ai_response_text}"
            st.session_state.chat_history.append({"role": "assistant", "text": error_message})
            
    except Exception as e:
        error_message = f"An unexpected error occurred with the AI connection: {e}. Please try again."
        st.session_state.chat_history.append({"role": "assistant", "text": error_message})

    finally:
        st.session_state.processing_user_input = False
        st.rerun()

# SECTION 4: Streamlit User Interface
def render_game_ui():
    """Renders the main game interface."""
    st.title("üßô The Generative Bard: Chronicle of the Ages")
    st.caption("An adventure with a memory that lasts.")
    
    chat_container = st.container(height=450, border=True)
    with chat_container:
        for message in st.session_state.chat_history:
            role = "user" if message["role"] == "user" else "assistant"
            with st.chat_message(role):
                st.markdown(message["text"])

    with st.sidebar:
        st.subheader("üéí Inventory")
        if st.session_state.inventory:
            for item, details in st.session_state.inventory.items():
                st.markdown(f"**{item}**")
                st.markdown(f"<small>{details['description']}</small>", unsafe_allow_html=True)
                st.markdown("---")
        else:
            st.info("Your inventory is empty.")

    user_prompt = st.chat_input("What do you do?", disabled=st.session_state.processing_user_input)
    if user_prompt:
        generate_response(user_prompt)

def render_start_screen():
    """Renders the game start screen."""
    st.title("üßô The Generative Bard")
    st.header("Chronicle of the Ages Edition")
    st.info("Embark on an epic adventure where your legend will be remembered.")
    if st.button("Start New Adventure", type="primary"):
        st.session_state.game_started = True
        with st.spinner("The Bard prepares the opening scene..."):
            initial_prompt = "The player is starting a new game. Describe the first scene and provide them with one or two initial items. Keep the narrative to a few sentences."
            generate_response(initial_prompt)
        st.rerun()

# SECTION 5: Main Application Flow
def main():
    """Orchestrates the main application flow."""
    st.set_page_config(page_title="The Generative Bard", page_icon="üßô", layout="wide")
    if st.session_state.game_started:
        render_game_ui()
    else:
        render_start_screen()

if __name__ == "__main__":
    main()

